[
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/go1.ja/",
        "title": "変数",
        "section": "blog",
        "tags": null,
        "date" : "2020.01.28",
        "body": "変数のタイプ y = x + 1において，xとyは値が変わり得るので「変数」と言う。プログラミングにおける「変数」もそうである。代入する値によって，箱である変数も変化する。\n変数の概念を理解するためには，簡単な算数をやってみるとよい。//で始まっているところは，注釈なので，プログラムを実行すると無視される。なので，わざわざそれまで書く必要はない。\n// プログラムの基準点になるファイルには，以下のように書いておく。 package main // 画面に文字列を出力  // main関数（function）を作ってみよう。 func main() { // varは「変数の宣言」を意味する。var aと書くと，名前がaの変数を宣言することになる。  // int は integer，つまり，「整数」の略である。  // var a int が意味するのは，「aという変数を宣言する。ただし，aのタイプは整数」である。  var a int var b int // 空っぽの変数aとbに，整数を入れてみよう。  a = 1 b = 2 // printは「画面に出力せよ」ということである。printlnは「画面に出力して一行開けろ」という意味。  println(a + b) } 以上のようにコードを書いて実行してみよう。ここではファイル名をmathにしている。\ngo run math.go\r 問題なければ，画面には3が表示される。\nint（整数） プログラミングでの変数は，タイプ（type）という属性を持つ。先ほどの変数aとbは，intだからタイプは「整数」である。ここに他のタイプ，たとえば，文字列「こんにちは」を入れることはできない。\nstring（文字列） 変数に文字列を入れたいのであれば，変数のタイプを変更する必要がある。変数に文字列を入れるためには，intの代わりにstringを使えばよい。ここで注意すべき点は，文字列を変数に入れるときに，文字列の前後にダブルクォーテーション（\u0026quot;\u0026quot;）を付けることである。\npackage main func main() { var a string var b string a = \u0026#34;こんにちは\u0026#34; b = \u0026#34;！\u0026#34; println(a + b) } これを実行してみると，「こんにちは！」が表示される。\nfloat（浮動小数） 整数と浮動小数は，どちらも数字だから同じタイプとして考えるかもしれないけど，違うタイプである。Go言語にはfloat32とfloat64がある。それぞれ，4バイトと8バイトを表す。\nbool（ブーリアン型） boolはブーリアン型（Boolean）で，trueとfalseの二つがある。初期値はfalse。\n面倒くさい 変数のタイプを毎回宣言するのは，面倒くさい。勝手に値のタイプを判断して，変数に入れてほしい。\nvar a int\ra = 1\r この2行は，次の1行で済む。\nvar a = 1\r このように書けるのは，整数に限った話ではない。\nvar a = 3.14\r varを書くのも面倒なので，もっと短くしてみよう。\na := 1\r これは，先ほどのvar a = 1と同じである。このようにすると，varとintを使ってわざわざタイプを宣言しなくて済む。楽々。\n色んな変数がある場合，紛らわしいかもしれない。そのようなときには，以下のようにして，どのようなタイプなのかを書いておくのが役に立つかもしれない。\nvar a int = 1\r Go言語のPrint Printについて少しだけ補足。fmtを利用するので，次のようにインポートしておく。\npackage main import ( \u0026#34;fmt\u0026#34; ) そして，aとbという変数に適当な値を割り当てて，次のようにしてみよう。変数に値を入れる方法がわからなければ，上にあるのでそちらに戻ろう。\nfmt.Printf(\u0026quot;%v\\n\u0026quot;, a + b)\r このようにすると，\u0026ldquo;\u0026ldquo;で囲ったところには，aとbを足した値が入り，画面に表示される。a + bがそのまま文字列として入るのではない。%vは，a + bの結果が「整数」「浮動小数」「文字列」等の中でどのタイプなのか，自ら判断する。\\nは改行。\n上にある1行は，次のようにすることと同じである。\nfmt.Println(a + b)\r ところで，fmtはピリオドでPrintfやPrintlnとつながっている。これは，fmtというパッケージからPrintfやPrintlnという機能を読み込んで使用する，という意味である。 fmtパッケージには，他にどのような機能があるのか，ここで確認できる。\nついでに，Printlnという機能を試してみよう。まずは，どのように使えるのかを確認。\nfunc Println(a ...interface{}) (n int, err error)\r 何かわからないやつが出てきた。a ... interface{}と，その右側にあるerr errorが何かわからない。文法の下には説明も書いてあるので，それも見てみる。\n Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.\n わかるようなわからないような…\nさらにその下には例が書いてある。外国語学習のときもそうだが，単語の説明を見てわからなかったのが，用例を見て「あ，わかった！」となる瞬間があると思う。プログラミング言語もいっしょだ。\nここでExampleを押すと，次の例が現れる。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { const name, age = \u0026#34;Kim\u0026#34;, 22 fmt.Println(name, \u0026#34;is\u0026#34;, age, \u0026#34;years old.\u0026#34;) // It is conventional not to worry about any \t// error returned by Println.  } 例といっしょに右下にはRunというボタンがある。押してみると「Program exited.」というメッセージとともに，Kim is 22 years old.が表示される。総合的に考えて見ると，constというのが何かはわからないが，なんとなく，nameとageにそれぞれKimという文字列（string）と22という整数（int）が入るような気がする。そして，それらの変数がfmt.Printlnというパッケージの機能で「name」と「age」という文字列といっしょに出力されるのではないだろうか。試しに，Kimと22を太郎と100に変えてプログラムを実行してみる。すると，次のように表示される。\n太郎 is 100 years old.\r Voilà!\n"
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/go2.ja/",
        "title": "演算子",
        "section": "blog",
        "tags": null,
        "date" : "2020.01.28",
        "body": "演算子の種類 項がいくつかによって「単項演算子」と「二項演算子」がある。\nGo言語には，次のような演算子がある。\n\u0026amp;はand，|はorである。^は，単項演算子として使われる場合はnot，二項演算子として使われる場合はxorである。したがって，a^bはxor，^bはnoである。\n"
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/go3.ja/",
        "title": "条件演算子と条件文",
        "section": "blog",
        "tags": null,
        "date" : "2020.01.27",
        "body": "条件演算子 条件演算子には，\u0026gt;（大なり）,\u0026lt;（小なり）,==（等しい）,!=（等しくない）,\u0026lt;=（小さいか等しい）,\u0026gt;=（大きいか等しい）がある。また，\u0026amp;\u0026amp;（かつ）,||（または）もあるが，これらはboolタイプの結果を二つ要する二項演算子である。\u0026amp;\u0026amp;は両者が真である場合にTrueに，||の場合は，どちらかの一方が真である場合，Trueを返す。以下のコードを実行するとtrueを返す。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a := 1 \u0026lt; 2 \u0026amp;\u0026amp; 3 \u0026lt; 4 fmt.Println(a) } 条件文 「もし，雨が降るのであれば，傘の売れ行きが伸びるだろう。」というのが条件文である。\nまずifを利用して条件を書く（もし，雨が降るのであれば）。その後，条件を満たした場合（true）はどのようにするかを書く。その次に，条件を満たさない場合（false）はどのようにするのかを書く。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a := 1 // aが3と等しければ…  if a == 3 { // 次の文を出力する。  fmt.Println(\u0026#34;aは3です。\u0026#34;) } // 等しくなければ，次の文を出力する。  fmt.Println(\u0026#34;aは3ではないです。\u0026#34;) } 上記は，elseを利用して次のように書くこともできる。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a := 1 // aが3と等しければ…  if a == 3 { // 次の文を出力する。  fmt.Println(\u0026#34;aは3です。\u0026#34;) // 等しくなければ，次の文を出力する。  } else { fmt.Println(\u0026#34;aは3ではないです。\u0026#34;) } } ときには，条件を増やしたい場合もある。「ウーロン茶ください。もし，なければ緑茶をください。それもなければ，水でいいでｓ。」のように。これを表すためには，ifとelseを組み合わせる。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a := 1 // aが3と等しければ…  if a == 3 { // 次の文を出力する。  fmt.Println(\u0026#34;aは3です。\u0026#34;) // aが2と等しければ，次の文を出力する。  } else if a == 2 { fmt.Println(\u0026#34;aは2です。\u0026#34;) } else { // aが3でも2でもない場合，以下を出力する。  fmt.Println(\u0026#34;aは3でも，2でもないです。\u0026#34;) } // 以下は条件文と関係ないので，なくても問題ない。  fmt.Println(\u0026#34;aは\u0026#34;, a, \u0026#34;です。\u0026#34;) } else ifは一つ以上あってもいいし，一番最後のelseはあってもいいし，なくてもいい。\n四則演算する計算機 package main import ( \u0026#34;fmt\u0026#34; // 標準入力のため  \u0026#34;os\u0026#34; // 入力から1行をもらうため  \u0026#34;bufio\u0026#34; // 文字列から入らない部分を削除するため  \u0026#34;strings\u0026#34; // stringをintに変えるため  \u0026#34;strconv\u0026#34; ) func main() { fmt.Println(\u0026#34;演算する数字を入力してください。\u0026#34;) reader := bufio.NewReader(os.Stdin) line, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) line = strings.TrimSpace(line) n1, _ := strconv.Atoi(line) fmt.Println(\u0026#34;数字をもう一つ入力してください。\u0026#34;) line, _ = reader.ReadString(\u0026#39;\\n\u0026#39;) line = strings.TrimSpace(line) n2, _ := strconv.Atoi(line) fmt.Printf(\u0026#34;入力した数字は，%d，%dです。\u0026#34;, n1, n2) fmt.Println(\u0026#34;続いて，演算子を「+, -, *, /」の中から選んでください。\u0026#34;) line, _ = reader.ReadString(\u0026#39;\\n\u0026#39;) line = strings.TrimSpace(line) if line == \u0026#34;+\u0026#34; { fmt.Printf(\u0026#34;%d + %d = %d\\n\u0026#34;, n1, n2, n1 + n2) } else if line == \u0026#34;-\u0026#34; { fmt.Printf(\u0026#34;%d - %d = %d\\n\u0026#34;, n1, n2, n1 - n2) } else if line == \u0026#34;*\u0026#34; { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, n1, n2, n1 * n2) } else if line == \u0026#34;/\u0026#34; { fmt.Printf(\u0026#34;%d / %d = %d\\n\u0026#34;, n1, n2, n1 / n2) } else { fmt.Println(\u0026#34;入力が間違っています。\u0026#34;) } } "
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/go4.ja/",
        "title": "switch-caseとfor文",
        "section": "blog",
        "tags": null,
        "date" : "2020.01.24",
        "body": "switch-case ifとelseを何回も繰り返して書くのは面倒だ。もっと短く書きたい。そこで使うのはswitchとcaseである。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;bufio\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { fmt.Println(\u0026#34;演算する数字を入力してください。\u0026#34;) reader := bufio.NewReader(os.Stdin) line, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) line = strings.TrimSpace(line) n1, _ := strconv.Atoi(line) fmt.Println(\u0026#34;数字をもう一つ入力してください。\u0026#34;) line, _ = reader.ReadString(\u0026#39;\\n\u0026#39;) line = strings.TrimSpace(line) n2, _ := strconv.Atoi(line) fmt.Printf(\u0026#34;入力した数字は，%d，%dです。\u0026#34;, n1, n2) fmt.Println(\u0026#34;続いて，演算子を「+, -, *, /」の中から選んでください。\u0026#34;) line, _ = reader.ReadString(\u0026#39;\\n\u0026#39;) line = strings.TrimSpace(line) switch line { case \u0026#34;+\u0026#34;: fmt.Printf(\u0026#34;%d + %d = %d\\n\u0026#34;, n1, n2, n1 + n2) case \u0026#34;-\u0026#34;: fmt.Printf(\u0026#34;%d - %d = %d\\n\u0026#34;, n1, n2, n1 - n2) case \u0026#34;*\u0026#34;: fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, n1, n2, n1 * n2) case \u0026#34;/\u0026#34;: fmt.Printf(\u0026#34;%d / %d = %d\\n\u0026#34;, n1, n2, n1 / n2) default: fmt.Println(\u0026#34;入力が間違っています。\u0026#34;) } } switchにあるものと一致するのかを，一番上にあるcaseから確認していく。もし，一致するのであれば，以下のcaseはチェックせずに，関数を抜け出す。したがって，条件に一致するケースが二つ以上並んでいる場合，最も上にあるcaseが優先的に実行されるのである。 なお，switchの値は省略できる。その場合，値はtrueと設定される。\nfor文 他の言語には，forとwhileの二つがある場合が多い。しかし，Go言語にはforしかない。\npackage main import \u0026#34;fmt\u0026#34; func main() { i := 0 for i \u0026lt; 10 { fmt.Println(i) // 以下は「i = i + 1」や「i += 1」と同じである。  i++ } fmt.Println(\u0026#34;最終的なiの値は\u0026#34;, i, \u0026#34;です。\u0026#34;) } for文には，「前処理文」「条件文」「後処理文」を表現することができる。\npackage main import \u0026#34;fmt\u0026#34; func main() { // 前処理文; 条件文; 後処理文  for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } fmt.Println(\u0026#34;最終的なiの値は\u0026#34;, i, \u0026#34;です。\u0026#34;) } しかし，上記のコードを実行するとエラーが生じる。iのスコープが問題となっているからだ。 for i := 0 以上のようにfor文の中で設定したiは，for文の外で使うことはできない。iのスコープはfor文の中までである。このとき，変数の宣言はfor文の外ですればいい。\npackage main import \u0026#34;fmt\u0026#34; func main() { // for文の外でiを宣言。  var i int // 前処理文（iに値を代入。宣言ではない。「:=」ではないことに注意。）; 条件文; 後処理文  for i = 0; i \u0026lt; 10; i++ { fmt.Println(i) } fmt.Println(\u0026#34;最終的なiの値は\u0026#34;, i, \u0026#34;です。\u0026#34;) } 変数の名前が同じくiになっているので紛らわしい。では，スコープの違いを浮き彫りにするために，変数の名前を変えてみよう。\npackage main import \u0026#34;fmt\u0026#34; func main() { // for文の外でjを宣言。  var j int // 前処理文; 条件文; 後処理文  for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } fmt.Println(\u0026#34;最終的なjの値は\u0026#34;, j, \u0026#34;です。\u0026#34;) } 「最終的なjの値は 0 です。」と出力される。つまり，iとjは異なる変数，ということである。可能であれば，変数名は人間が読んで紛らわしくない名前にするのがいい。\nbreakとcontinue for文に条件を書かないと，trueとして認識し，無限ループとなる。また，for文は，breakとcontinueと組み合わせる場合も多い。\nbreakを使うことにより，iは10にならず，5になったときに，for文をbreakする。\npackage main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { if i == 5 { break } fmt.Println(i) } } 一方，continueは該当する値を飛ばして，次の作業を続ける。\npackage main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { if i == 5 { continue } fmt.Println(i) } } for文で九九 package main import \u0026#34;fmt\u0026#34; func main() { for base := 1; base \u0026lt;= 9; base++ { fmt.Printf(\u0026#34;%dの段\\n\u0026#34;, base) for j := 1; j \u0026lt;= 9; j++ { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, base, j, base * j) } // 「Println()」のように何も書かないと，一行空ける。  fmt.Println() } } "
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/go5.ja/",
        "title": "関数",
        "section": "blog",
        "tags": null,
        "date" : "2020.01.20",
        "body": "関数 プログラミングにおける関数は，特定な機能を集めておいたものだと考えればいい。 Go言語で関数はfuncから始まる。そして，最後に得られた値はreturnで返される。 プログラマーは，なぜ関数を使うのだろうか。ここには二つの理由があると思われる。一つは，繰り返しが嫌なので特定の機能を「モジュール化」したいからであり，もう一つは，機能を分離したいからであろう。 ある機能をモジュール化しておくと，自分がその機能を手軽に使えるだけでなく，他の人もそれを呼び出し，簡単に使うことができる。その際，モジュールの中には，なるべく最小限の機能を含んでいるのが望ましい。余計なものまで読み込む必要はないし，機能別に分けている方が読みやすいし，メンテナンスもしやすいからである。\n簡単な関数を作ってみよう。\npackage main import \u0026#34;fmt\u0026#34; // 引数として関数がもらうのは，intタイプのxとy二つである。returnで返されるのは，intタイプ一つのみである。 func add(x int, y int) int { return x + y } func main() { for i := 0; i \u0026lt; 10; i++ { // add関数を呼び出し，iとi+2という引数を渡す。  // 最初に渡されるのは0と2である。次は1と3が渡される。  fmt.Printf(\u0026#34;%d + %d = %d\\n\u0026#34;, i, i+2, add(i, i+2)) } } もう一つ，関数を作ってみよう。二つのfuncの位置は，一方が上でも，下でも関係ない。\npackage main import \u0026#34;fmt\u0026#34; func main() { // `fun1`という関数を呼び出して，引数として2と3を渡す。  // `return`された結果は，それぞれaとbという変数に格納される。  a, b := fun1(2, 3) fmt.Println(a, b) } // `return`するのが二つ以上の場合，括弧で囲む。 func fun1(x, y int) (int, int) { // xとyを受け取ったが，返すのは逆の順番であるyとx。  return y, x } 関数の中で，他の関数を呼び出すこともできる。\npackage main import \u0026#34;fmt\u0026#34; func main() { a, b := fun1(2, 3) fmt.Println(a, b) } func fun1(x, y int) (int, int) { // 関数fun2を呼び出す。  fun2(x, y) return y, x } // 上にあるfun1のx，yは，下のfun2にあるx，yは，同じものではない。 // 人間が読んでわかりやすい変数名を付けよう。 func fun2(x, y int) { fmt.Println(\u0026#34;fun2\u0026#34;, x, y) } 関数の再帰呼び出し 関数の中で，他の関数ではなく，自分自身を呼び出すこともできる。これを再帰呼び出し（recursive call）と言う。\npackage main import \u0026#34;fmt\u0026#34; func main() { f1(10) } func f1(x int) { // xが0に等しい場合は，`f1`関数が終わる。  // `main`関数に戻るのは`return`が実行された後である。  if x == 0 { return } fmt.Println(x) // 関数`f1`の中で，再び関数`f1`を呼び出す。  f1(x - 1) } 再帰呼び出しを利用して，1から10まで足していく関数を作ってみよう。\npackage main import \u0026#34;fmt\u0026#34; func main() { // `sum`関数に10と0を渡す。  // 結果が`return`されると変数sに格納する。  s := sum(10, 0) fmt.Println(s) } // 最初に，xとsには10と0が代入される。 func sum(x int, s int) int { // xが0になった場合，sを返す。  if x == 0 { return s } // sにxの値を足してsの値を更新する。  // 最初は，10 = 10 + 0なのでsは10。  s += x // 再帰呼び出しで`sum`関数を呼び出す。  // 最初は，10と10が渡されが，x-1なので9と10。  return sum(x-1, s) } 結果として，55が出力される。\n上記のような関数の再帰呼び出しの代わりに，for文を使うこともできる。逆に，for文を再帰呼び出しを利用して書くことも可能である。それでは，どちらを使うべきか。それは目的によって違ってくる。\nfor文より，再帰呼び出しを利用した方がいい例として，フィボナッチ数列を考えてみよう。\nフィボナッチ数列は，以下のように定義される。\n f(0)=1 f(1)=1 f(x)=f(x-1)+f(x-2)  たとえば，f(2)の場合，f(2-1)+f(2-2)，つまり，f(1)+f(0)なので定義に従って結果は2となる。そして，f(3)は3，f(4)は5のようになる。\nそれでは，フィボナッチ数列を再帰呼び出しを使って書いてみよう。\npackage main import \u0026#34;fmt\u0026#34; func main() { // ここでは，f(10)の値を求めてみよう。  result := f(10) fmt.Println(result) } func f(x int) int { // f(0)=1  if x == 0 { return 1 } // f(1)=1  if x == 1 { return 1 } // f(x)=f(x-1)+f(x-2)  return f(x-1) + f(x-2) } 結果は，89である。このように，数学的に定義されているものをプログラミングする場合は，再帰呼び出しを用いるのがよい。これをfor文で表すこともできるが，やや難しい。\n再帰呼び出しは，for文より遅い。にもかかわらず，再帰呼び出しを使う理由の一つは，数学的定義をよく表現できるからである。\nHaskell，Lisp，Scalaのような関数型プログラミング言語は，再帰呼び出しに特化されている。そのため，メモリの消費や速度など，あまり気にせず，再帰呼び出しを使うことができる。一方，Go言語は関数型言語ではないので，メモリの消費量も多く，遅い。そのため，同じ結果を導き出すのに，再帰呼び出しより，for文の方が早いと言える。むろん，上記のような簡単なプログラミングだけを見ると，どちらにしても関係なさそうだが。\n"
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/go6.ja/",
        "title": "配列",
        "section": "blog",
        "tags": null,
        "date" : "2020.01.19",
        "body": "配列の宣言 変数には一つ以上の値を入れることもできる。配列（array）を使えば，たくさんの値を格納することができる。\npackage main import \u0026#34;fmt\u0026#34; func main() { // 箱（配列）を10個作ろう。箱のタイプは整数タイプ。  var A [10]int // len(A)は，変数Aの長さ（length）を意味する。  // つまり，len(A)は10と書くのと同じ。  for i := 0; i \u0026lt; len(A); i++ { // Aという箱にi*iの値を入れる。  A[i] = i * i } fmt.Println(A) } ちなみに，文字列（string）も配列である。「Hello world!」は12byteからなっている配列である。英数字1文字やスペース一つは，1byteに該当する。Go言語では，UTF-8（1～4byteを使用してUnicode文字を表す）を使用する。ASCII文字は，1byteで済むが，漢字やハングルなどは，2～4byteが必要である。\npackage main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;Hello World!\u0026#34; for i := 0; i \u0026lt; len(s); i++ { fmt.Print(s[i], \u0026#34;, \u0026#34;) } } 上記を実行すると「Hello world!」の文字コード，つまり，72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33が現れる。英語は1byteからなっているのがわかる。一方，漢字や平仮名，ハングルは3byteである。\npackage main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;Hello 世界!\u0026#34; for i := 0; i \u0026lt; len(s); i++ { fmt.Print(s[i], \u0026#34;, \u0026#34;) } } 72, 101, 108, 108, 111, 32, 228, 184, 150, 231, 149, 140, 33と出力される。「世界」に該当する部分は228, 184, 150, 231, 149, 140で，1文字3byteである。\npackage main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;Hello 世界!\u0026#34; // runeは変数のタイプの一つ。  // runeタイプは1～3byteの長さを持つ。  // runeタイプは文字（英語・漢字など）によって長さが変わる。  s2 := []rune(s) for i := 0; i \u0026lt; len(s2); i++ { fmt.Print(s2[i], \u0026#34;, \u0026#34;) } } これの結果は72, 101, 108, 108, 111, 32, 19990, 30028, 33である。これは合計13byteであり，9byteではない。19990や30028，つまり，「世」と「界」はそれぞれ3byteである。 runeはいつ使うのだろうか。文字列の長さを文字単位で求めたい場合，runeタイプにしないと，1byte以上の文字は文字化けする。言い換えると，「世」に該当する3byteが228, 184, 150と出力されるので，文字化けするのである。これらを一つにまとめるためにruneを使うと，「世」は19990となり，文字化けしない。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;unicode/utf8\u0026#34; ) func main() { world1 := \u0026#34;world\u0026#34; world2 := \u0026#34;世界の平和\u0026#34; fmt.Println(utf8.RuneCountInString(world1)) fmt.Println(utf8.RuneCountInString(world2)) } 上記を実行すると，いずれも5となる。それぞれの文字列が五つのruneを持つのである。\n配列のコピー 配列をコピーしたい場合は，どのようにすればいいのだろうか。早速例を見てみよう。\npackage main import \u0026#34;fmt\u0026#34; func main() { // 新しい配列を作り，数字を格納  arr := [5]int{1, 2, 3, 4, 5} // また新しい配列を作る  clone := [5]int{} for i := 0; i \u0026lt; 5; i++ { // 配列をコピー  clone[i] = arr[i] } fmt.Println(clone) } 上記は配列を順序もそのままコピーした。今度は逆順にコピーしてみよう。\npackage main import \u0026#34;fmt\u0026#34; func main() { arr := [5]int{1, 2, 3, 4, 5} // forはarrの長さの半分繰り返す  for i := 0; i \u0026lt; len(arr)/2; i++ { // 二重代入を使う  // 左のarr[i]にはarr[len(arr)-1-i]が入る  // 左のarr[len(arr)-1-i]にはarr[i]が入る  arr[i], arr[len(arr)-1-i] = arr[len(arr)-1-i], arr[i] } fmt.Println(arr) } 真ん中の3はそのままなので，いじらなくてもいい。\nRadix Sort ※　以下の内容は，やや専門的なところに踏み込むので，飛ばしても関係ない。\nRADIXアルゴリズムは，単純，かつ，速い。元素の範囲が十分に限定されており，配列の個数が少ないときに適切である。「元素の範囲」は，たとえば，「1から100まで」，または，「-100000から100000まで」のようなものを意味する。後者のように，元素の範囲が広い場合，RADIXアルゴリズムは不利である。ソートをするアルゴリズムはRADIX以外にもいくつかあるので，このように元素の範囲が広いときには，他のアルゴリズムを使うのがいいだろう。\n以下のプログラムを実行すると，配列に入っている{0, 5, 4, 9, 1, 2, 8, 3, 6, 4, 5}が[0 1 2 3 4 4 5 5 6 8 9]のように，ソートされる。\npackage main import \u0026#34;fmt\u0026#34; func main() { // 以下の配列をソートしたい  arr := [11]int{0, 5, 4, 9, 1, 2, 8, 3, 6, 4, 5} // 上記の配列をソートするために必要な箱は，0から9までの10個  // arr配列に10は入っていないので，temp配列に無駄な箱（10）を作る必要はない  temp := [10]int{} for i := 0; i \u0026lt; len(arr); i++ { // arr配列に入っている数字を，順番に読み込み，変数（index）に格納する  index := arr[i] // arr配列にある数字が何個あったのかを数えて，temp配列に格納する  temp[index]++ } idx := 0 // temp配列の長さより小さければ，繰り返す  for i := 0; i \u0026lt; len(temp); i++ { // 現在，temp配列は[1 1 1 1 2 2 1 0 1 1]となっている  // なので，最大の繰り返しの回数は2回  for j := 0; j \u0026lt; temp[i]; j++ { // 最初はarr配列の最初の箱に入っている数字（0）を（0）に書き換える  // arr配列の2番目に入っている数字は5だが，i（1）に書き換える  // 同じ数字が二つある場合，temp配列はそれを2で表している  // jが2より小さい場合，作業は2回繰り返されるので，  // arr配列には同じ数字が連続して2回プッシュされる  arr[idx] = i // 5，6番目の配列（arr[idx]）に4（i）は2回プッシュされる  idx++ } } fmt.Println(arr) } 数字以外には，たとえば，ローマ字で書かれている人の名前をアルファベットの順番で並び替えることができる。RADIXソートは使用場面が限られているので，プログラミングをする前に，まず，この方法が使用可能なのかどうかを確認しておいた方がいいだろう。\n"
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/markdown-syntax/",
        "title": "マークダウン",
        "section": "blog",
        "tags": ["markdown","css","html","themes"],
        "date" : "2019.03.11",
        "body": "日本語はどうかな。 This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  "
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/rich-content/",
        "title": "Rich Content",
        "section": "blog",
        "tags": ["shortcodes","privacy"],
        "date" : "2019.03.10",
        "body": "Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n Instagram Simple Shortcode .__h_instagram.card { font-family: -apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif; font-size: 14px; border: 1px solid rgb(219, 219, 219); padding: 0; margin-top: 30px; } .__h_instagram.card .card-header, .__h_instagram.card .card-body { padding: 10px 10px 10px; } .__h_instagram.card img { width: 100%; height: auto; }  koloot.design   View More on Instagram    YouTube Privacy Enhanced Shortcode    Twitter Simple Shortcode .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; }  “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Graphic Design History (@DesignReviewed) January 17, 2019  Vimeo Simple Shortcode  .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }  "
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/placeholder-text/",
        "title": "Placeholder Text",
        "section": "blog",
        "tags": ["markdown","text"],
        "date" : "2019.03.09",
        "body": "Mole et vultus populifer quaque primoque non Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n"
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/math-typesetting/",
        "title": "Math Typesetting",
        "section": "blog",
        "tags": null,
        "date" : "2019.03.08",
        "body": "Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:    To enable KaTex globally set the parameter math to true in a project's configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions Examples Inline math: \\( \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… \\)\nBlock math:\n\\[ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } \\]\n"
    }
,
    {
        "ref": "https://trusting-spence-e71272.netlify.app/blog/emoji-support/",
        "title": "Emoji Support",
        "section": "blog",
        "tags": ["emoji"],
        "date" : "2019.03.05",
        "body": "Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }"
    }
]
