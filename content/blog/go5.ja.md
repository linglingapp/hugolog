---
title: "関数"
# description: "https"
date: 2020-01-20T00:36:14+09:00
draft: false
---

## 関数
プログラミングにおける関数は，特定な機能を集めておいたものだと考えればいい。
Go言語で関数は`func`から始まる。そして，最後に得られた値は`return`で返される。
プログラマーは，なぜ関数を使うのだろうか。ここには二つの理由があると思われる。一つは，繰り返しが嫌なので特定の機能を「モジュール化」したいからであり，もう一つは，機能を分離したいからであろう。
ある機能をモジュール化しておくと，自分がその機能を手軽に使えるだけでなく，他の人もそれを呼び出し，簡単に使うことができる。その際，モジュールの中には，なるべく最小限の機能を含んでいるのが望ましい。余計なものまで読み込む必要はないし，機能別に分けている方が読みやすいし，メンテナンスもしやすいからである。

簡単な関数を作ってみよう。

{{< highlight Go >}}
package main

import "fmt"

// 引数として関数がもらうのは，intタイプのxとy二つである。returnで返されるのは，intタイプ一つのみである。
func add(x int, y int) int {
    return x + y
}

func main() {
    for i := 0; i < 10; i++ {
        // add関数を呼び出し，iとi+2という引数を渡す。
        // 最初に渡されるのは0と2である。次は1と3が渡される。
        fmt.Printf("%d + %d = %d\n", i, i+2, add(i, i+2))
    }
}
{{< /highlight >}}

もう一つ，関数を作ってみよう。二つのfuncの位置は，一方が上でも，下でも関係ない。

{{< highlight Go >}}
package main

import "fmt"

func main() {
    // `fun1`という関数を呼び出して，引数として2と3を渡す。
    // `return`された結果は，それぞれaとbという変数に格納される。
    a, b := fun1(2, 3)

    fmt.Println(a, b)   
}

// `return`するのが二つ以上の場合，括弧で囲む。
func fun1(x, y int) (int, int) {
    // xとyを受け取ったが，返すのは逆の順番であるyとx。
    return y, x
}
{{< /highlight >}}

関数の中で，他の関数を呼び出すこともできる。

{{< highlight Go >}}
package main

import "fmt"

func main() {
    a, b := fun1(2, 3)

    fmt.Println(a, b)   
}

func fun1(x, y int) (int, int) {
    // 関数fun2を呼び出す。
    fun2(x, y)
    return y, x
}

// 上にあるfun1のx，yは，下のfun2にあるx，yは，同じものではない。
// 人間が読んでわかりやすい変数名を付けよう。
func fun2(x, y int) {
    fmt.Println("fun2", x, y)
}
{{< /highlight >}}

## 関数の再帰呼び出し
関数の中で，他の関数ではなく，自分自身を呼び出すこともできる。これを再帰呼び出し（recursive call）と言う。

{{< highlight  Go >}}
package main

import "fmt"

func main() {
    f1(10)
}

func f1(x int) {
    // xが0に等しい場合は，`f1`関数が終わる。
    // `main`関数に戻るのは`return`が実行された後である。
    if x == 0 {
        return
    }
    fmt.Println(x)
    // 関数`f1`の中で，再び関数`f1`を呼び出す。
    f1(x - 1)
}
{{< /highlight >}}

再帰呼び出しを利用して，1から10まで足していく関数を作ってみよう。

{{< highlight  Go >}}
package main

import "fmt"

func main() {
    // `sum`関数に10と0を渡す。
    // 結果が`return`されると変数sに格納する。
    s := sum(10, 0)
    fmt.Println(s)
}

// 最初に，xとsには10と0が代入される。
func sum(x int, s int) int {
    // xが0になった場合，sを返す。
    if x == 0 {
        return s
    }
    // sにxの値を足してsの値を更新する。
    // 最初は，10 = 10 + 0なのでsは10。
    s += x
    // 再帰呼び出しで`sum`関数を呼び出す。
    // 最初は，10と10が渡されが，x-1なので9と10。
    return sum(x-1, s)
}
{{< /highlight >}}

結果として，55が出力される。

上記のような関数の再帰呼び出しの代わりに，for文を使うこともできる。逆に，for文を再帰呼び出しを利用して書くことも可能である。それでは，どちらを使うべきか。それは目的によって違ってくる。

for文より，再帰呼び出しを利用した方がいい例として，[フィボナッチ数列](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0)を考えてみよう。

フィボナッチ数列は，以下のように定義される。

* f(0)=1
* f(1)=1
* f(x)=f(x-1)+f(x-2)

たとえば，f(2)の場合，f(2-1)+f(2-2)，つまり，f(1)+f(0)なので定義に従って結果は2となる。そして，f(3)は3，f(4)は5のようになる。

それでは，フィボナッチ数列を再帰呼び出しを使って書いてみよう。

{{< highlight Go >}}
package main

import "fmt"

func main() {
    // ここでは，f(10)の値を求めてみよう。
    result := f(10)
    fmt.Println(result)
}

func f(x int) int {
    // f(0)=1
    if x == 0 {
        return 1
    }
    // f(1)=1
    if x == 1 {
        return 1
    }
    // f(x)=f(x-1)+f(x-2)
    return f(x-1) + f(x-2)
}
{{< /highlight >}}

結果は，89である。このように，数学的に定義されているものをプログラミングする場合は，再帰呼び出しを用いるのがよい。これをfor文で表すこともできるが，やや難しい。

再帰呼び出しは，for文より遅い。にもかかわらず，再帰呼び出しを使う理由の一つは，数学的定義をよく表現できるからである。

Haskell，Lisp，Scalaのような関数型プログラミング言語は，再帰呼び出しに特化されている。そのため，メモリの消費や速度など，あまり気にせず，再帰呼び出しを使うことができる。一方，**Go言語は関数型言語ではない**ので，メモリの消費量も多く，遅い。そのため，同じ結果を導き出すのに，再帰呼び出しより，for文の方が早いと言える。むろん，上記のような簡単なプログラミングだけを見ると，どちらにしても関係なさそうだが。

여기서도 알아보도록 하자.